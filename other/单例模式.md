# 单例模式

单例模式是指。确保每个类只有一个实例，而且自行实例化并且向系统提供这个实例。

- 单例类只能有一个实例
- 单例类必须自己创建自己的唯一实例
- 单例类必须给所有其他对象提供这一唯一实例

单例模式保证了全局对象的唯一性

## 单例模式的实现

1.饿汉模式(静态常量)



```java
    // 1.饿汉模式（静态常量）
    private static final Hungry hun = new Hungry();
    private Hungry() {}
    public static Hungry getobject()
    {
        return hun;
    }
```

2.饿汉模式(静态代码块)

```java
    // 2. 饿汉模式(静态代码块)
    private Hungry(){};
    private static Hungry hun;
    static {
        hun = new Hungry();
    }
    public static Hungry getobject()
    {
        return hun;
    }
```



3.懒汉模式(线程不安全)

```java
    // 3.懒汉模式 (线程不安全)
    private static IdlerTest idt;
    private IdlerTest(){};

    public static IdlerTest getobject()
    {
        if (idt == null)
        {
            idt = new IdlerTest();
        }
        return idt;
    }
```



### synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： 

　　1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 

　　2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 

　　3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 

　　4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。

4.懒汉模式(线程安全，同步方法)

```java
// 4.懒汉模式(线程安全，同步方法)
    private static IdlerTest idt;
    private IdlerTest(){};
    public static synchronized IdlerTest getobject()
    {
        if (idt == null) {
            idt = new IdlerTest();
        }
        return idt;
    }
```

5.懒汉模式(线程安全，同步代码)

```java
    // 5.懒汉式 ()
    private static IdlerTest idt;
    private IdlerTest(){};
    public static synchronized IdlerTest getobject()
    {
        if (idt == null) {
            synchronized (IdlerTest.class){
                idt = new IdlerTest();
            }
        }
        return idt;
    }
```

6.双重检查

```java
// 6. 双重检查
    private static IdlerTest idt;
    private IdlerTest(){};
    public static synchronized IdlerTest getobject()
    {
        if (idt == null) {
            synchronized (IdlerTest.class){
                if (idt == null) {
                    idt = new IdlerTest();
                }

            }
        }
        return idt;
    }
```

7.静态内部类

```java
public class InnerClass {

    private InnerClass(){};

    private static class Singleton{
        private static final InnerClass sing = new InnerClass();
    }
    public static InnerClass getobject()
    {
        return Singleton.sing;
    }

}
```



8.枚举

```java
public enum OneObject {
    OBJECT
}

```



### 推荐的方式

双重检查和静态内部类或者枚举的方式



## 单例模式的优点

系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。

## 单例模式的缺点

当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。

## 单例模式的使用场景

• 需要频繁的进行创建和销毁的对象；
• 创建对象时耗时过多或耗费资源过多，但又经常用到的对象；
• 工具类对象；
• 频繁访问数据库或文件的对象。











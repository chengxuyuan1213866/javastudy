##  List，Set，Map三者的区别及总结

1.List：顺序的
List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象

2.Set:独一无二
不允许重复的集合。不会有多个元素引用相同的对象。

3.Map:用Key来搜索
使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。

## Arraylist 与 LinkedList 区别

Arraylist底层使用的是数组（存读数据效率高，插入删除特定位置效率低）。
LinkedList底层使用的是双向循环链表数据结构（插入，删除效率特别高）。
学过数据结构这门课后我们就知道采用链表存储，插入，删除元素时间复杂度不受元素位置的影响，都是近似O（1）而数组为近似O（n），因此当数据特别多，而且经常需要插入删除元素时建议选用LinkedList.一般程序只用Arraylist就够用了，因为一般数据量都不会蛮大，Arraylist是使用最多的集合类。

## ArrayList 与 [Vector](https://so.csdn.net/so/search?q=Vector&spm=1001.2101.3001.7020) 区别

Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector ，代码要在同步操作上耗费大量的时间。

Arraylist不是同步的，所以在不需要同步时建议使用Arraylist。

## HashMap 和 Hashtable 的区别

HashMap是非线程安全的，HashTable是线程安全的；HashTable内部的方法基本都经过synchronized修饰。
因为线程安全的问题，HashMap要比HashTable效率高一点，HashTable基本被淘汰。
HashMap允许有null值的存在，而在HashTable中put进的键值只要有一个null，直接抛出NullPointerException。

## HashSet和HashMap的区别

![image-20230907001746799](https://s2.loli.net/2023/09/07/TwBxVG9ukSEztCh.png)



## HashMap 和 ConcurrentHashMap的区别



ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）
HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。

##  HashSet如何检查重复

当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。


集合框架底层数据结构总结
Collection

List

1. Arraylist：数组（查询快,增删慢 线程不安全,效率高 ）
2. Vector：数组（查询快,增删慢 线程安全,效率低 ）
3. LinkedList：链表（查询慢,增删快 线程不安全,效率高 ）

Set

1. HashSet（无序，唯一）:哈希表或者叫散列集(hash table)
2. LinkedHashSet：链表和哈希表组成 。 由链表保证元素的排序 ， 由哈希表证元素的唯一性
3. TreeSet（有序，唯一）：红黑树(自平衡的排序二叉树。)

Map

1. HashMap：基于哈希表的Map接口实现（哈希表对键进行散列，Map结构即映射表存放键值对）
2. LinkedHashMap:HashMap 的基础上加上了链表数据结构
3. HashTable:哈希表
4. TreeMap:红黑树（自平衡的排序二叉树）
   